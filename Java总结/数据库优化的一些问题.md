# 数据库优化

### 1. 数据库优化方面的事情

- 定位：查找，定位慢查询，并优化
- 优化手段：
  1. **创建索引**：创建合适的索引，我们就可以先在索引中进行查询，查询到后直接找对应的记录。
  2. **分表**：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来进行优化
  3. **读写分离**：当一台服务器不能满足需求时，采用读写分离的方式进行集群
  4. **缓存**：使用redis来进行缓存



### 2. 查找慢查询和定位慢查询？

> 在项目自验或项目转测试之前，在启动MySQL数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定时间后，通过查看日志找到慢查询语句。
使用explain慢查询语句，来详细分析语句的问题。


### 3. 数据库优化之数据库表设计遵循范式
数据库表设计时需要遵循范式：（见前面，数据库表设计三范式）


### 4. 选择合适的数据库引擎
#### 4.1 存储引擎 myisam/innodb/memory
> 开发中，我们经常使用的存储引擎 myisam/innodb/memory
- Myisam存储引擎：
  > 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎，比如bbs中的发帖，回复表。

- innodb存储引擎：
    > 对事务要求高，保存的数据都是重要数据，我们建议使用innodb，比如订单表，账号表。

- Memory存储：
    > 当数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory，速度极快。


#### 4.2 myisam和innodb的区别：
1. 事务安全 myisam不支持事务而innodb支持
2. 查询和添加速度myisam不用支持事务就不用考虑同步锁，查找和添加和添加的速度快。
3. 支持全文索引 myisam支持，innodb不支持
4. 锁机制  myisam支持表锁，innodb支持行锁（事务）
5. 外键myisam不支持外键，innodb支持外键，（通常不设置外键，通常是在程序中保证数据的一致）


### 5. 数据库优化之创建合适的索引？
>索引（index）是帮助dbms高效获取数据的数据结构。
> 分类：普通索引/唯一索引/主键索引/全文索引

- **普通索引**：允许重复的值的出现
- **唯一索引**：除了不能有重复记录外，其他和普通索引一个样（用户名称，用户的身份证，用户的email等）
- **主键索引**：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会根据列创建索引，这就是主键索引，唯一且没有null值。
- **全文索引**：用来对表中的文本域（char，varchar，text）进行索引，全文索引针对myisam
explain select * from articles where match (title,body) against('database');



### 6. 使用索引的一些技巧
#### 6.1 索引的弊端：
  1. 占用磁盘空间。
  2. 对dml（插入，修改，删除）操作有影响，变慢。
#### 6.2 使用场景：
> 总结：满足以下条件的字段，才应该创建索引。
  1. 肯定在where条件经常使用，不会出现在where子句中字段不该创建索引。如果不是查询就没有意义
  2. 该字段的内容不是唯一的几个值
  3. 字段内容不是频繁变化

#### 6.3 具体技巧：
1. 对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。
2. 对于使用like的查询，查询如果是"%aaa"不会使用到索引而"aaa%"会使用到索引。
3. 如果条件中有or，有条件没有使用索引，即使其中有条件索引也不会使用，换言之，就是要求使用的所有字段，都必须单独使用时能够使用索引。
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。
5. 如果mysql估计使用全表扫描比使用索引快，则不使用索引。（比如表里面只有一条数据）

### 7. 数据库优化之分表
> 分表分为水平（按行）分表和垂直（按列）分表

- 根据经验，MySQL表数据一般达到百万级别，查询效率会很低，容易造成表顿，甚至堆积很多连接，直接挂掉。水平分表能够很大程度减小这些压力。

- 如果一张表中某个字段值非常多（长文本，二进制等），而且只有在很少的情况下会查询，这个时候就可以把字段多的单独放在一个表，通过外键关联起来。
比如：考试详情，一般我们只关注分数，不关注详情。
- 1. 按时间分表
这个分表方式有一定的局限性，当数据有较强的时效性，如微博发送记录，微信消息记录等，这种数据很少有用户查询几个月前的数据，那就可以按月分表。
- 2. 按区间范围分表
一般在有严格的自增ID需求上，如按照user_id水平分表：
table_1  user_id  从1~100W
table_2  user_id  从101~200W
table_3  user_id  从201~300W
- 3. hash分表
通过一个原始目标的ID或者名称通过一定的hash算法计算出数据存储表的表名，然后访问相应的表。

### 8. 数据库的读写分离
> 一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多，一台服务器满足不了要求时就可以用集群处理，MySQL的集群处理技术最常用的就是读写分离。

- 主从同步
数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据时一致的，能改变数据库数据的操作都往主数据库去写，而其他的数据库从主数据库上同步数据。
- 读写分离
使用负载均衡来实现写的操作都往主数据库去，而读的操作从服务器去。



### 9. 数据库优化之缓存
> 在持久层（dao）和数据库(db)之间添加一个缓存层，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库，而缓存是在操作内存级的，访问速度更快。

> 作用：减少数据库服务器压力，减少访问事件。

Java中常用的缓存有，hibernate的二级缓存。该缓存不能完成分布式缓存。
可以用redis来作为中央缓存。


### 10. sql语句优化小技巧
#### 10.1 DDL优化：
1. 通过禁用索引来提供导入数据性能，这个操作主要是针对有数据库的表，追加数据
```sql
//去除键
alert table test3 DISABLE keys;
//批量插入数据
insert into test3 select * from test;
//恢复键
alert table test3 ENABLE keys;
```
2. 关闭唯一校验
```sql
set unique_checks=0 关闭
set unique_checks=1开启
```
3. 修改事务提交方式（导入）（变多次提交为一次）
```sql
set autocommit=0 关闭
//批量插入
set autocommit=1 开启
```
DML优化（变多次提交为一次）
```sql
insert into test value(1,2);
insert into test value(1,3);
insert into test value(1,4);
//合并多为一条
insert into test value(1,2)(1,3)(1,4)
```
#### 10.2 DQL优化
- order by 优化
  1. 多用索引排序
  2. 普通结果排序（非索引排序）Filesort
- group by 优化
是使用order by null，取消默认排序
- 子查询优化
  
例如：在客户列表找不到在支付列表的客户

```sql
//在客户列表找不到在“支付列表”的客户，查询没买过东西的客户
explain
select * from customer where customer_id not in(select DISTINCT customer_id from payment);#子查询   ----这种是基于func外链
```
### 11. jdbc批量插入几百万条数据
- 1. 变多次提交为一次
- 2. 使用批量操作
  
省出的时间非常可观。
> 像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现。
